# 大小端和位域测试

~~~C
// 定义联合体
typedef union{
    unsigned int data1;
    unsigned char data2;
}Endian;

bool isBigEndian()
{
    bool flag;
    unsigned int data = 0x12345678;
    Endian *pEndian = (Endian *)(&data);
    flag = (pEndian->data2 == 0x12) ? true : false;
    prtinf("int=0x%X, char=0x%X \n", 
          pEndian->data1,
          pEndian->data2);
    printf("%s \n", ((flag == true) ? "BigEndian" : "LittleEndian"));
    return flag;
}

typedef struct{
    unsigned int first:4;
    unsigned int second:8;
    unsigned int third:16;
    unsigned int fourth:4;
}HighLow;

void highLowTest()
{
    unsigned int data = 0x12345678;
    HighLow *pHighLow = (HighLow *)(&data);
    printf("data=0x%X, first:4=0x%X, second:8=0x%X, third:16=0x%X\n",
           data,
           pHighLow->first,
           pHighLow->second,
           pHighLow->third);
}
~~~

0x12345678 = 0001 0010 0011 0100 0101 0110 0111 1000b

小端位域如下：输出data=0x12345678, first:4=0x8, second:8=0x67, third:16=0x2345

|    0001     | 0010 0011 0100 0101 |  0110 0111  |    1000    |
| :---------: | :-----------------: | :---------: | :--------: |
| fourth:4bit |     third:16bit     | second:8bit | first:4bit |

注意：位域定义不能跨越所属类型，否则中间会有空位，如下：

~~~c
// 正常无空位
typedef struct{
    unsigned int first:4;
    unsigned int second:8;
    unsigned int third:16;
    unsigned int fourth:4;
}HighLow;

// first和second有空4位，fourth后也有4位空
typedef struct{
    unsigned char first:4;
    unsigned char second:8;
    unsigned short third:16;
    unsigned char fourth:4;
}HighLow;
// 相当于如下：
typedef struct{
    unsigned char first:4;
    unsigned char :4;			// 空4位 不能访问
    unsigned char second:8;
    unsigned short third:16;
    unsigned char fourth:4;
    unsigned char :4;			// 空4位 不能访问
}HighLow;
~~~



